<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Clojure threading macros in ES6 - Esteban Sastre</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="Clojure threading macros in ES6" />
<meta property="og:description" content="While working in the functionality for getting a docker-compose path from the cursor position, I realized at some point I was writing constantly code like this:
let first_result = func_call1(val); let second_result = func_call2(first_result); let third_result = func_call3(second_result); ...etc... This is not necessarily bad, it improves code readability and helps to reason about the flow of execution, normally better than calling those functions in a nested way:
func_call3(func_call2(func_call1(val))); // Phew. But yet, it feels somewhat cumbersome to nest too many function calls that way." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/clojure-macros-in-es6/" />
<meta property="article:published_time" content="2017-09-10T18:40:44+00:00" />
<meta property="article:modified_time" content="2017-09-10T18:40:44+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Clojure threading macros in ES6"/>
<meta name="twitter:description" content="While working in the functionality for getting a docker-compose path from the cursor position, I realized at some point I was writing constantly code like this:
let first_result = func_call1(val); let second_result = func_call2(first_result); let third_result = func_call3(second_result); ...etc... This is not necessarily bad, it improves code readability and helps to reason about the flow of execution, normally better than calling those functions in a nested way:
func_call3(func_call2(func_call1(val))); // Phew. But yet, it feels somewhat cumbersome to nest too many function calls that way."/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" /><link rel="stylesheet" type="text/css" href="/css/dark.css" media="(prefers-color-scheme: dark)" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
		<script src="/js/main.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	
		<div class="avatar">
			<a href="/">
				<img src="wizard.png" alt="Esteban Sastre" />
			</a>
		</div>
	
	<h1 class="site-title"><a href="/">Esteban Sastre</a></h1>
	<div class="site-description"><p>Pretty much everything that crosses my mind, thoughts and ramblings</p><nav class="nav social">
			<ul class="flat"><li><a href="https://github.com/fr0gs/" title="Github"><i data-feather="github"></i></a></li><li><a href="/index.xml" title="RSS"><i data-feather="rss"></i></a></li></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/posts">All posts</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
			<li>
				<a href="/tags">Tags</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">10</span>
							<span class="rest">Sep 2017</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">Clojure threading macros in ES6</h1>
				</div>
			</div>
					
			<div class="markdown">
				<p>While working in the functionality for <a href="https://estebansastre.com/getting-docker-compose-path-from-cursor-position/">getting a docker-compose path from the cursor position</a>, I realized at some point I was writing constantly code like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#00f">let</span> first_result = func_call1(val);
<span style="color:#00f">let</span> second_result = func_call2(first_result);
<span style="color:#00f">let</span> third_result = func_call3(second_result);

...etc...
</code></pre></div><p>This is not necessarily bad, it improves code readability and helps to reason about the flow of execution, normally better than calling those functions in a nested way:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">func_call3(func_call2(func_call1(val))); <span style="color:#008000">// Phew.
</span></code></pre></div><p>But yet, it feels somewhat cumbersome to nest too many function calls that way. Some time ago I started looking into Clojure for fun and discovered <a href="https://clojure.org/guides/threading_macros">threading macros</a>. <a href="https://clojuredocs.org/clojure.core/-%3E">Thread first</a> (<strong>'-&gt;&rsquo;</strong>) and <a href="https://clojuredocs.org/clojure.core/-%3E%3E">Thread last</a>(<strong>-&raquo;</strong>) macros pipe the result of the application of a function to a value to the next function in the list. The difference is that thread first adds the result as the first argument to the next function and thread last to the last one.</p>
<p>Wouldn't it be nice to have some kind of mechanism in Javascript?. Looking around I found someone had already written <a href="https://jondavidjohn.com/clojure-threading-macros-in-javascript/">a nice article about it</a>. The target is to have a function to be called like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#00f">let</span> result = thread(<span style="color:#a31515">&#34;-&gt;&#34;</span>, <span style="color:#a31515">&#34;3&#34;</span>, 
                        parseInt,
                        [sum, 3],
                        [diff, 10],
                        str); <span style="color:#008000">// &#34;-4&#34;
</span></code></pre></div><p>And what would be going on under the hood is this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#00f">let</span> sameresult = diff(sum(3, parseInt(<span style="color:#a31515">&#34;3&#34;</span>)), 10);
</code></pre></div><p>So I decided to reimplement the code taking advantage of the new features that came along with <strong>ES6</strong>(arrow functions, destructuring, rest parameters&hellip;).</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#00f">const</span> thread = (operator, first, ...args) =&gt; {
    <span style="color:#00f">let</span> isThreadFirst;
    <span style="color:#00f">switch</span> (operator) {
        <span style="color:#00f">case</span> <span style="color:#a31515">&#39;-&gt;&gt;&#39;</span>:
            isThreadFirst = <span style="color:#00f">false</span>;
            <span style="color:#00f">break</span>
        <span style="color:#00f">case</span> <span style="color:#a31515">&#39;-&gt;&#39;</span>:
            isThreadFirst = <span style="color:#00f">true</span>;
            <span style="color:#00f">break</span>;
        <span style="color:#00f">default</span>:
            <span style="color:#00f">throw</span> <span style="color:#00f">new</span> Error(<span style="color:#a31515">&#39;Operator not supported&#39;</span>);
            <span style="color:#00f">break</span>;
    }
    <span style="color:#00f">return</span> args.reduce((prev, next) =&gt; {
        <span style="color:#00f">if</span> (Array.isArray(next)) {
            <span style="color:#00f">const</span> [head, ...tail] = next;
            <span style="color:#00f">return</span> isThreadFirst ? head.apply(<span style="color:#00f">this</span>, [prev, ...tail]) : head.apply(<span style="color:#00f">this</span>, tail.concat(prev));
        }
        <span style="color:#00f">else</span> {
            <span style="color:#00f">return</span> next.call(<span style="color:#00f">this</span>, prev);
        }
    }, first);
}
</code></pre></div><p>So when executing the code using the thread first operator for example:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#00f">let</span> result = thread(<span style="color:#a31515">&#34;-&gt;&#34;</span>, <span style="color:#a31515">&#34;3&#34;</span>, 
                        parseInt,
                        [sum, 3],
                        [diff, 10],
                        str); <span style="color:#008000">// &#34;-4&#34;
</span><span style="color:#008000"></span>
console.log(result); <span style="color:#008000">// -4 
</span></code></pre></div><p>and using the thread last operator:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#00f">let</span> result = thread(<span style="color:#a31515">&#34;-&gt;&gt;&#34;</span>, <span style="color:#a31515">&#34;3&#34;</span>, 
                        parseInt,
                        [sum, 3],
                        [diff, 10],
                        str); <span style="color:#008000">// &#34;-4&#34;
</span><span style="color:#008000"></span>
console.log(result); <span style="color:#008000">// 4 
</span></code></pre></div><p>Have fun!</p>
<h1 id="links">Links:</h1>
<ul>
<li><a href="https://blog.nilenso.com/blog/2016/05/12/threading-macros-in-clojure/">Threading macros in Clojure</a></li>
<li><a href="https://jondavidjohn.com/clojure-threading-macros-in-javascript/">Threading macros in plain old javascript</a></li>
<li><a href="https://clojuredocs.org/clojure.core/-%3E%3E">Thread last clojure</a></li>
<li><a href="https://clojuredocs.org/clojure.core/-%3E">Thread first clojure</a></li>
</ul>

			</div>

			<div class="tags">
				
					
						<ul class="flat">
							
							<li><a href="/tags/javascript">javascript</a></li>
							
							<li><a href="/tags/es6">es6</a></li>
							
						</ul>
					
				
			</div><div id="disqus_thread"></div>
<script type="text/javascript">
	(function () {
		
		
		if (window.location.hostname == "localhost")
			return;

		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		var disqus_shortname = 'ink-demo';
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
		Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div> <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-99848055-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script>feather.replace()</script>
</body>
</html>
